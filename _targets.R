library(targets)
library(tarchetypes)
source("R/packages.R")
source("R/functions.R")

# Specify location of raw data
data_raw <- "_targets/user/data_raw"

# Specify location of intermediate results file
int_dir <- "_targets/user/intermediates"

# Specify location of final results file
results_dir <- "_targets/user/results"

# Set parallel back-end
plan(callr)

# Set options:
# - Use targets workspaces for debugging
# - Track dependencies in some packages
tar_option_set(
  workspace_on_error = TRUE,
  imports = c("taxastand", "pteridocat")
  )

# Define Rmd targets outside of main workflow
# to avoid meaningless warnings
data_readme_tar <- tar_render(
    data_readme,
    "reports/data_readme/data_readme.Rmd",
    output_dir = results_dir,
    output_format = "readmedown::plain_document",
    knit_root_dir = "reports/data_readme"
  )

ftolr_readme_tar <- tar_render(
    ftolr_readme,
    "reports/ftolr_readme/ftolr_readme.Rmd",
    output_dir = path(results_dir, "ftolr"),
    output_file = "README.txt",
    output_format = "readmedown::plain_document",
    knit_root_dir = "reports/ftolr_readme"
  )

tar_plan(
  # Load data ----
  # Pteridocat taxonomic database
  pteridocat = pteridocat::pteridocat,
  # Modified PPGI taxonomy
  # with new genera and slightly different treatments following World Ferns list
  tar_file(
    ppgi_taxonomy_path,
    path(data_raw, "ppgi_taxonomy_mod.csv")),
  ppgi_taxonomy = read_csv(ppgi_taxonomy_path),
  # Equisetum subgenus level taxonomy
  tar_file(equisteum_subgen_path, path(data_raw, "equisetum_subgenera.csv")),
  # List of coding genes to extract from plastomes
  # (based on genes of Wei et al 2017, then trimmed to non-duplicated genes)
  tar_file(
    target_plastome_genes_path,
    path(data_raw, "target_coding_genes.txt")),
  target_plastome_genes = read_lines(target_plastome_genes_path),
  # Outgroup plastome accessions
  # (Some species names later get updated in plastome_metadata_renamed due to
  # pulling most recent taxonomy from NCBI)
  tar_file(
    plastome_outgroups_path,
    path(data_raw, "plastome_outgroups.csv")),
  plastome_outgroups = read_csv(plastome_outgroups_path),
  # Manually curated list of GenBank accessions to exclude from analysis
  tar_file(
    accs_exclude_path,
    path(data_raw, "accs_exclude.csv")),
  accs_exclude = read_csv(accs_exclude_path),
  # Reference alignments for assembling genes
  # generated by prep_ref_seqs_plan.R
  tar_file(
    ref_aln_files,
    list.files(
      path(data_raw, "ref_aln"),
      pattern = "\\.fasta",
      full.names = TRUE)
  ),
  fern_ref_seqs = load_ref_aln(ref_aln_files),
  # NCBI taxonomic database
  # downloaded from
  # https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump_archive/taxdmp_2022-02-01.zip #nolint
  tar_file(taxdump_zip_file, path(data_raw, "taxdmp_2022-02-01.zip")),
  # Fossil calibration points
  tar_file(
    fossil_dates_path,
    path(data_raw, "fern_fossils.csv")
  ),
  # Fossil calibration points from Testo and Sundue 2016 SI
  tar_files_input(
    testo_sundue_2016_si_path,
    "_targets/user/data_raw/1-s2.0-S1055790316302287-mmc2.xlsx"
  ),

  # Prep for assembling Sanger plastid regions ----
  # Define variables used in plan:
  # - Target plastid loci (coding genes and spacers)
  target_loci = c(
    "atpA", "atpB", "matK", "rbcL", "rps4",
    "trnL-trnF", "rps4-trnS"),
  # - Target spacers only
  target_spacers = target_loci[str_detect(target_loci, "-")],
  # - Target plastome loci (full set of plastome genes plus spacers)
  target_plastome_loci = c(target_plastome_genes, target_spacers),
  # - Most recent date cutoff for sampling genes
  date_cutoff = "2021/12/31",

  # Download and extract Sanger sequences ----
  # Download raw fasta files
  tar_target(
    fern_sanger_seqs_raw,
    fetch_fern_sanger_seqs(
      target_loci,
      end_date = date_cutoff),
    pattern = map(target_loci),
    # don't run in parallel, or will get HTTP status 429 errors
    deployment = "main"
  ),
  # Extract target regions with superCRUNCH
  tar_target(
    fern_sanger_extract_res,
    extract_from_ref_blast(
      query_seqtbl = fern_sanger_seqs_raw,
      ref_seqtbl = fern_ref_seqs,
      target = target_loci,
      blast_flavor = "dc-megablast",
      other_args = c("-m", "span", "--threads", "4")
    ),
    pattern = map(target_loci)
  ),
  raw_fasta_all = clean_extract_res(fern_sanger_extract_res, "dc-megablast"),
  # Drop excluded sequences
  raw_fasta = anti_join(raw_fasta_all, accs_exclude, by = "accession"),
  # Fetch metadata
  tar_target(
    raw_meta_all,
    fetch_fern_metadata(
      target_loci,
      end_date = date_cutoff),
    pattern = map(target_loci),
    deployment = "main"
  ),
  raw_meta = unique(raw_meta_all) %>%
    # Drop excluded sequences from metadata
    anti_join(accs_exclude, by = "accession"),

  # Resolve taxonomic names for Sanger sequences ----
  # Specify varieties to exclude from collapsing
  # during taxonomic name resolution
  varieties_to_keep = define_varieties_to_keep(),
  # Extract species names from NCBI taxonomic database
  tar_target(
    ncbi_names_raw,
    extract_ncbi_names(
      taxdump_zip_file, taxid_keep = raw_meta,
      names_exclude = ncbi_db_names_to_exclude(),
      workers = 20),
    deployment = "main"),
  # Clean NCBI species names
  ncbi_names_full = clean_ncbi_names(ncbi_names_raw),
  # Exclude invalid names (hybrids, taxa not identified to species level)
  ncbi_names_query = exclude_invalid_ncbi_names(ncbi_names_full),
  # Parse reference names
  pc_ref_names = ts_parse_names(
    unique(pteridocat$scientificName), tbl_out = TRUE, quiet = TRUE),
  # Resolve names, round 1: NCBI accepted scientific names
  ncbi_names_query_round_1 = select_ncbi_names_round_1(ncbi_names_query),
  # - match names to reference
  match_results_raw_round_1 = ts_match_names(
    query = ncbi_names_query_round_1$scientific_name,
    reference = pc_ref_names,
    max_dist = 5, match_no_auth = TRUE,
    match_canon = TRUE, collapse_infra = TRUE,
    collapse_infra_exclude = varieties_to_keep),
  # - resolve synonyms
  match_results_resolved_round_1 = ts_resolve_names(
    match_results_raw_round_1, pteridocat),
  # Resolve names, round 2: NCBI synonym scientific names
  ncbi_names_query_round_2 = select_ncbi_names_round_2(
    match_results_resolved_round_1, ncbi_names_query),
  match_results_raw_round_2 = ts_match_names(
    query = ncbi_names_query_round_2$scientific_name,
    reference = pc_ref_names,
    max_dist = 5, match_no_auth = TRUE,
    match_canon = TRUE, collapse_infra = TRUE,
    collapse_infra_exclude = varieties_to_keep),
  match_results_resolved_round_2 = ts_resolve_names(
    match_results_raw_round_2, pteridocat),
  # Resolve names, round 3: NCBI species without author
  ncbi_names_query_round_3 = select_ncbi_names_round_3(
    match_results_resolved_round_1,
    match_results_resolved_round_2, ncbi_names_query),
  match_results_raw_round_3 = ts_match_names(
    query = ncbi_names_query_round_3$species,
    reference = pc_ref_names,
    max_dist = 5, match_no_auth = TRUE,
    match_canon = TRUE, collapse_infra = TRUE,
    collapse_infra_exclude = varieties_to_keep),
  match_results_resolved_round_3 = ts_resolve_names(
    match_results_raw_round_3, pteridocat),
  # Combine name resolution results
  match_results_resolved_all =
    combined_match_results(
      ncbi_names_query = ncbi_names_query,
      match_results_resolved_round_1,
      match_results_resolved_round_2,
      match_results_resolved_round_3),
  # Map NCBI names to accepted names
  ncbi_accepted_names_map = make_ncbi_accepted_names_map(
    match_results_resolved_all),
  # Inspect name resolution results
  pterido_names_to_inspect = inspect_ts_results(match_results_resolved_all),

  # Remove rogues from Sanger sequences ----
  # Combine sanger sequences and metadata, filter to resolved names
  # - set minimum lengths (bp) for filtering genes and spacers
  min_gene_len = 200,
  min_spacer_len = 20,
  sanger_seqs_combined_filtered = combine_and_filter_sanger(
    raw_meta, raw_fasta, ncbi_accepted_names_map,
    min_gene_len, min_spacer_len),
  # Make BLAST database including all fern sequences
  tar_file(
    sanger_blast_db,
    make_fern_blast_db(
      seqtbl = sanger_seqs_combined_filtered,
      blast_db_dir = path(int_dir, "blast_sanger"),
      out_name = "ferns_sanger")
  ),
  # Group query sequences for parallel computing
  tar_group_count(
    sanger_blast_query,
    dplyr::select(sanger_seqs_combined_filtered, seq, otu),
    count = 30), # number of jobs to run in parallel
  # Conduct all-by-all blast in parallel
  tar_target(
    all_by_all_blast,
    blast_seqtbl(
      seqtbl = sanger_blast_query,
      blastdb_files = sanger_blast_db
    ),
    pattern = map(sanger_blast_query)
  ),
  # Identify rogues (sequences matching wrong family)
  sanger_seqs_rogues = detect_rogues(
    metadata_with_seqs = sanger_seqs_combined_filtered,
    blast_results = all_by_all_blast,
    ppgi = ppgi_taxonomy),
  sanger_seqs_rogues_inspected = inspect_rogues(
    sanger_seqs_rogues,
    raw_meta_all,
    ncbi_names_query,
    ppgi_taxonomy),
  sanger_seqs_rogues_removed = anti_join(
    sanger_seqs_combined_filtered,
    sanger_seqs_rogues,
    by = c("accession", "target")
  ),

  # Check for species monophyly in Sanger loci ----
  # - split sequence tibble up by target loci
  tar_target(
    mpcheck_sliced,
    filter(sanger_seqs_rogues_removed, target == target_loci),
    pattern = map(target_loci)
  ),
  # - align each locus
  tar_target(
    mpcheck_aligned,
    align_seqs_tbl(mpcheck_sliced),
    pattern = map(mpcheck_sliced)
  ),
  # - trim each locus
  # 1% missing cutoff for spacers, 5% otherwise nolint
  # name by accession since includes multiple sequences per species
  mpcheck_trimmed = trim_genes(mpcheck_aligned, name_col_in = "accession"),
  # - build tree for each locus
  tar_target(
    mpcheck_tree,
    build_tree_from_alignment_df(mpcheck_trimmed, program = "fasttree"),
    pattern = map(mpcheck_trimmed)
  ),
  # - check monophyly
  tar_target(
    mpcheck_monophy,
    check_monophy(mpcheck_sliced, mpcheck_tree, workers = 32),
    pattern = map(mpcheck_sliced, mpcheck_tree),
    deployment = "main"
  ),

  # Select final Sanger sequences ----
  # First parse specimen voucher data
  sanger_seqs_with_voucher_data = parse_voucher(sanger_seqs_rogues_removed),
  # Join sequences across species, then select one set of sequences per species
  # Criteria for joining sequences across species:
  # - species is monophyletic, or
  # - all sequences for that species are from the same voucher, or
  # - all sequences for that species are from same publication
  # Criteria for selecting final set of sequences for each species (in order):
  # - 1: specimens with longest rbcL + any other gene
  # - 2: specimens with longest rbcL
  # - 3: specimens with longest combined non-rbcL genes
  # - 4: specimens with longest non-combined non-rbcL genes
  sanger_accessions_selection = select_genbank_genes(
    sanger_seqs_with_voucher_data, mpcheck_monophy),

  # Download core set of plastid genes from plastomes ----
  # Download plastome metadata (accessions and species)
  plastome_metadata_raw_all = download_plastome_metadata(
    end_date = date_cutoff,
    outgroups = plastome_outgroups),
  # Drop sequences to exclude
  plastome_metadata_raw = anti_join(
    plastome_metadata_raw_all,
    accs_exclude, by = "accession"
  ),
  # Extract species names in plastome data from NCBI taxonomy
   plastome_ncbi_names_raw = extract_ncbi_names(
     taxdump_zip_file, taxid_keep = plastome_metadata_raw,
     names_exclude = plastome_ncbi_db_names_to_exclude(),
     workers = 2),
  # Resolve species names in plastome metadata
  # (drops accession if name could not be resolved)
  plastome_metadata_renamed = resolve_pterido_plastome_names(
    plastome_ncbi_names_raw, plastome_metadata_raw, plastome_outgroups,
    pc_ref_names, pteridocat
  ),
  # Download plastome sequences
  # FASTA files for each accession in seqtbl format
  target_plastome_accessions = unique(plastome_metadata_renamed$accession),
  plastome_fasta = read_genbank(target_plastome_accessions),
  # Extract target genes and spacers with superCRUNCH
  tar_target(
    fern_plastome_loci_extract_res,
    extract_from_ref_blast(
      query_seqtbl = mutate(plastome_fasta, gene = target_plastome_loci),
      ref_seqtbl = fern_ref_seqs,
      target = target_plastome_loci,
      blast_flavor = "dc-megablast",
      other_args = c("-m", "span", "--threads", "4")
    ),
    pattern = map(target_plastome_loci)
  ),
  # Combine plastome metadata and sequences, filter to best accession per taxon
  plastome_seqs_combined_filtered = select_plastome_seqs(
    plastome_genes_raw,
    plastome_metadata_renamed,
    fern_plastome_loci_extract_res),

  # Align spacers ----
  # Assign taxonomic clusters (by family) for aligning spacer regions
  tar_target(
    plastid_spacers_unaligned,
    assign_tax_clusters(
      sanger_accessions_selection,
      sanger_seqs_combined_filtered,
      plastome_seqs_combined_filtered,
      ppgi_taxonomy, plastome_metadata_renamed,
      target_spacers
    ),
    pattern = map(target_spacers),
  ), # - configure groups for aligning in parallel
  tar_target(
    plastid_spacers_unaligned_grouped,
    plastid_spacers_unaligned %>%
      filter(cluster != "none") %>%
      group_by(target, cluster) %>%
      tar_group(),
    iteration = "group"
  ),
  # Align each cluster
  tar_target(
    plastid_spacers_aligned_clusters,
    align_seqs_tbl(plastid_spacers_unaligned_grouped),
    pattern = map(plastid_spacers_unaligned_grouped),
    iteration = "vector"
  ),
  # Trim each cluster, rename each sequence by taxon
  # (Use a very light threshold, to keep most gaps)
  plastid_spacers_aligned_trimmed_clusters = trim_spacers_by_cluster(
    plastid_spacers_aligned_clusters),
  # Also make overall alignment with one representative
  # per cluster to identify sequences needing reverse-complement
  tar_target(
    plastid_spacers_rep_align,
    align_rep_spacers(
      plastid_spacers_aligned_trimmed_clusters, # clusters
      plastid_spacers_unaligned, # singletons
      target_select = target_spacers,
      exclude_terms = "Anemiaceae"), # exclude Anemiaceae, too variable to align
    pattern = map(target_spacers)
  ),
  # Reverse-complement spacers
  plastid_spacers_aligned_trimmed_reversed_clusters = reverse_spacers(
    plastid_spacers_aligned_trimmed_clusters, plastid_spacers_rep_align
  ),
  # Merge subalignments
  tar_target(
    plastid_spacers_aligned_trimmed,
    merge_spacer_alignments(
      plastid_spacers_aligned_trimmed_reversed_clusters,
      n_threads = 10,
      target_select = target_spacers),
    pattern = map(target_spacers)
  ),

  # Align genes ----
  # Combine Sanger and plastome genes into single dataframe, group by gene
  tar_group_by(
    plastid_genes_unaligned,
    combine_sanger_plastome(
      # Exclude spacer regions (spacer regions have hyphen in name)
      sanger_accessions_selection %>%
        select(-contains("-")),
      sanger_seqs_combined_filtered %>%
        filter(str_detect(target, "-", negate = TRUE)),
      plastome_seqs_combined_filtered %>%
        filter(str_detect(target, "-", negate = TRUE))
      ),
    target),
  # Align sequences by gene
  tar_target(
    plastid_genes_aligned,
    align_seqs_tbl(plastid_genes_unaligned),
    pattern = map(plastid_genes_unaligned)
  ),
  # Trim alignments, rename each sequence by taxon
  plastid_genes_aligned_trimmed = trim_genes(plastid_genes_aligned),

  # Concatenate alignments ----
  # - tbl format
  sanger_alignment_tbl = concatenate_plastid_sanger(
    plastid_genes_aligned_trimmed,
    plastid_spacers_aligned_trimmed,
    target_loci, type_select = "sanger"
  ),
  plastome_alignment_tbl = concatenate_plastid_sanger(
    plastid_genes_aligned_trimmed,
    plastid_spacers_aligned_trimmed,
    target_loci, type_select = "plastome"
  ),
  # - ape format
  sanger_alignment = concatenate_to_ape(sanger_alignment_tbl),
  plastome_alignment = concatenate_to_ape(plastome_alignment_tbl),

  # Phylogenetic analysis ----
  # Backbone consensus tree
  tar_target(
    plastome_tree,
    iqtree(
      plastome_alignment,
      m = "MFP", # test model followed by ML analysis
      bb = 1000, nt = 12, seed = 20220123,
      redo = TRUE, echo = TRUE, wd = path(int_dir, "iqtree/plastome"),
      other_args = c(
        "-mset", "GTR", # only test GTR models
        "-mrate", "E,I,G,I+G", # don't test free-rate models
        "-t", "PARS"),
      tree_path = path(
        int_dir, "iqtree/plastome/plastome_alignment.phy.contree")
    ),
    deployment = "main"
  ),
  # write out as plastome tree to use as constraint
  tar_file(
    constraint_tree_file,
    write_tree_tar(
      plastome_tree,
      path(int_dir, "iqtree/constraint.tre")
    )
  ),
  # Initial Sanger tree (fast mode)
  tar_target(
    sanger_tree_fast,
    iqtree(
      sanger_alignment,
      m = "GTR+I+G", nt = 6, seed = 20220129,
      redo = TRUE, echo = TRUE, wd = path(int_dir, "iqtree/sanger_fast"),
      other_args = c(
        "-fast",
        "-t", "PARS",
        "-alrt", "1000",
        "-g", path_abs(constraint_tree_file)
      )
    )
  ),
  # Sanger ML tree: first try (one replicate)
  tar_target(
    sanger_ml_tree,
    iqtree(
      sanger_alignment,
      m = "MFP", bb = 1000, nt = 6, seed = 20220129,
      redo = FALSE, # FIXME: change to TRUE on next run
      echo = TRUE, wd = path(int_dir, "iqtree/sanger"),
      other_args = c(
        "-mset", "GTR",
        "-mrate", "E,I,G,I+G",
        "-t", "PARS",
        "-g", path_abs(constraint_tree_file),
        "-nm", "2000", # changed from 1000 when bs didn't converge
        "--undo" # FIXME: delete this on next run
      ),
      # Return best ML tree and consensus
      tree_path = c(
        ml_tree = path(int_dir, "iqtree/sanger/sanger_alignment.phy.treefile"),
        con_tree = path(int_dir, "iqtree/sanger/sanger_alignment.phy.contree")
      )
    )
  ),
  # Sanger ML tree: best of 10 replicates
  # - set 10 different seeds
  iqtree_sanger_seeds = 220307 + 1:10,
  iqtree_sanger_dirs = path(int_dir, paste0("iqtree/sanger_", 1:10)),
  # - run 10 independent reps
  tar_target(
    sanger_ml_tree_rep,
    iqtree(
      sanger_alignment,
      # model same as determined by ML search with 1 replicate
      # (see _targets/user/intermediates/iqtree/sanger)
      # Next time, change to
      # "-mset", "GTR", "-mrate", "E,I,G,I+G"
      # to test models directly
      m = "GTR+F+I+G4",
      bb = 1000, nt = 6,
      seed = iqtree_sanger_seeds,
      redo = FALSE, # change to TRUE when starting pipeline from new data
      wd = iqtree_sanger_dirs,
      other_args = c(
        "-t", "PARS",
        "-g", path_abs(constraint_tree_file)
      ),
      tree_path = c(
        ml_tree = path(iqtree_sanger_dirs, "sanger_alignment.phy.treefile"),
        con_tree = path(iqtree_sanger_dirs, "sanger_alignment.phy.contree")
      ),
    ),
    pattern = map(iqtree_sanger_seeds, iqtree_sanger_dirs),
    iteration = "list"
  ),
  # Read in log files for each replicate
  tar_target(
    sanger_ml_log_rep,
    read_lines_tar(
      path(iqtree_sanger_dirs, "sanger_alignment.phy.log"),
      depends = sanger_ml_tree_rep
    ),
    pattern = map(iqtree_sanger_dirs, sanger_ml_tree_rep)
  ),
  # Read in log file from Sanger ML tree analysis
  sanger_ml_log = get_best_tree(sanger_ml_log_rep, "log"),
  # Load Sanger ML tree (call 'mlr' to distinguish from ML tree with 2000 reps)
  sanger_mlr_tree = get_best_tree(sanger_ml_log_rep, "ml"),
  # Load Sanger consensus tree
  sanger_con_tree = get_best_tree(sanger_ml_log_rep, "con"),
  # Check monophyly ----
  # Root ML tree on bryophytes
  sanger_mlr_tree_rooted = root_fern_tree(sanger_mlr_tree),
  # Root consensus tree
  sanger_con_tree_rooted = root_fern_tree(sanger_con_tree),
  # Load Equisetum data (only group with subgenera in fossils)
  equisetum_subgen = load_equisetum_subgen(
    equisteum_subgen_path,
    sanger_mlr_tree_rooted), # ML or consensus doesn't matter
  # Define groups for checking monophyly
  taxa_levels_check = c(
    "order", "suborder", "family",
    "subfamily", "genus", "subgenus"),
  # Make tibble mapping species to putatively monophyletic groups
  sanger_sampling = make_sanger_sampling_tbl(
    plastome_metadata_renamed,
    sanger_tree = sanger_mlr_tree_rooted, # ML or consensus doesn't matter
    ppgi_taxonomy = ppgi_taxonomy) %>%
    # Add Equisetum subgenera
    left_join(equisetum_subgen, by = "species"),
  ,
  # Check monophyly
  # - ML tree
  ml_mono_test = assess_monophy(
    taxon_sampling = sanger_sampling,
    tree = sanger_mlr_tree_rooted,
    tax_levels = taxa_levels_check
  ),
  ml_monophy_by_clade = map_df(
    seq_along(taxa_levels_check),
    ~get_result_monophy(ml_mono_test, .)
  ),
  # - consensus tree
  con_mono_test = assess_monophy(
    taxon_sampling = sanger_sampling,
    tree = sanger_con_tree_rooted,
    tax_levels = taxa_levels_check
  ),
  con_monophy_by_clade = map_df(
    seq_along(taxa_levels_check),
    ~get_result_monophy(con_mono_test, .)
  ),
  # Prepare fossil calibrations ----
  # Load fossil calibration points
  fossil_ferns_raw = read_csv(fossil_dates_path),
  # Drop MD formatting (asterisks) from data
  fossil_ferns_all = mutate(
    fossil_ferns_raw,
    across(where(is.character), ~str_remove_all(., "\\*"))),
  # Filter fossil calibration points
  fossil_calibration_points = filter_fossil_calibration_points(
    fossil_ferns_all),
  # Define some tips for spanning non-monophyletic groups
  manual_spanning_tips = define_manual_spanning_tips("this_study"),
  # Specify calibration point for root
  ml_root_calibration = calibrate_root_node(
    sanger_mlr_tree_rooted, "land_plants", 475,
    "Anthoceros_angustus", "Polypodium_virginianum"
  ),
  con_root_calibration = calibrate_root_node(
    sanger_con_tree_rooted, "land_plants", 475,
    "Anthoceros_angustus", "Polypodium_virginianum"
  ),
  # Map species in the tree to their fossil groups
  # - ML tree
  ml_fossil_node_species_map = make_fossil_species_map(
    sanger_mlr_tree_rooted, fossil_calibration_points,
    ppgi_taxonomy, equisetum_subgen, plastome_metadata_renamed,
    include_algaomorpha = TRUE),
  # - consensus tree
  con_fossil_node_species_map = make_fossil_species_map(
    sanger_con_tree_rooted, fossil_calibration_points,
    ppgi_taxonomy, equisetum_subgen, plastome_metadata_renamed,
    include_algaomorpha = TRUE),
  # Get pairs of tips that define fossil groups
  # - ML tree
  ml_fossil_calibration_tips = get_fossil_calibration_tips(
    ml_fossil_node_species_map, sanger_mlr_tree_rooted,
    fossil_calibration_points, manual_spanning_tips
  ),
  # - consensus tree
  con_fossil_calibration_tips = get_fossil_calibration_tips(
    con_fossil_node_species_map, sanger_con_tree_rooted,
    fossil_calibration_points, manual_spanning_tips
  ),
  # Format fossil calibration points for treePL
  # - ML tree
  ml_fossil_calibrations_for_treepl = format_calibrations_for_treepl(
    ml_fossil_calibration_tips, ml_root_calibration
  ),
  # - consensus tree
  con_fossil_calibrations_for_treepl = format_calibrations_for_treepl(
    con_fossil_calibration_tips, con_root_calibration
  ),
  # Format Testo and Sundue 2016 calibration points for comparison
  # (consensus tree only)
  ts_fossil_calibration_points = parse_ts_calibrations(
    testo_sundue_2016_si_path),
  ts_fossil_node_species_map = make_ts_fossil_species_map(
    sanger_con_tree_rooted, ts_fossil_calibration_points, ppgi_taxonomy,
    plastome_metadata_renamed),
  ts_manual_spanning_tips = define_manual_spanning_tips("ts2016"),
  ts_fossil_calibration_tips = get_fossil_calibration_tips(
    ts_fossil_node_species_map, sanger_con_tree_rooted,
    ts_fossil_calibration_points, ts_manual_spanning_tips
  ),
  ts_fossil_calibrations_for_treepl = format_calibrations_for_treepl(
    ts_fossil_calibration_tips, con_root_calibration
  ),
  # Dating with treePL ----
  # - ML tree, FernCal calibrations
  sanger_mlr_tree_dated = run_treepl_combined(
    phy = sanger_mlr_tree_rooted,
    alignment = sanger_alignment,
    calibration_dates = ml_fossil_calibrations_for_treepl,
    cvstart = 1000,
    cvstop = 0.000001,
    cvsimaniter = 5000,
    plsimaniter = 200000, # preliminary output suggested > 100000
    nthreads = 5,
    seed = 7168,
    wd = path(int_dir, "treepl/ml"),
    thorough = TRUE
  ),
  # - ML tree, Testo and Sundue calibrations
  ts_sanger_tree_dated = run_treepl_combined(
    phy = sanger_con_tree_rooted,
    alignment = sanger_alignment,
    calibration_dates = ts_fossil_calibrations_for_treepl,
    cvstart = 1000,
    cvstop = 0.000001,
    cvsimaniter = 5000,
    plsimaniter = 200000,
    nthreads = 5,
    seed = 7167,
    wd = path(int_dir, "treepl/ts"),
    thorough = TRUE
  ),
  # - Consensus tree, FernCal calibrations
  sanger_con_tree_dated = run_treepl_combined(
    phy = sanger_con_tree_rooted,
    alignment = sanger_alignment,
    calibration_dates = con_fossil_calibrations_for_treepl,
    cvstart = 1000,
    cvstop = 0.000001,
    cvsimaniter = 5000,
    plsimaniter = 200000,
    nthreads = 5,
    seed = 7167,
    wd = path(int_dir, "treepl/con"),
    thorough = TRUE
  ),
  # Format data for ftolr ----
  acc_table_long = make_long_acc_table(
    raw_meta, sanger_seqs_combined_filtered,
    plastome_seqs_combined_filtered,
    ncbi_names_query, sanger_accessions_selection,
    plastome_metadata_renamed,
    plastome_metadata_raw,
    plastome_ncbi_names_raw),
  acc_table_wide = make_wide_acc_table(
    acc_table_long, sanger_accessions_selection),
  plastome_parts_table = make_parts_table(
    plastome_alignment_tbl, plastome_alignment),
  sanger_parts_table = make_parts_table(
    sanger_alignment_tbl, sanger_alignment),
  plastome_tree_rooted = phytools::reroot(
    plastome_tree,
    getMRCA(plastome_tree,
      c("Physcomitrium_patens", "Marchantia_polymorpha", "Anthoceros_angustus"))
  ),
  # Write out data for ftolr ----
  # - Accessions
  tar_file(
    acc_table_long_ftolr,
    write_csv_tar(
      acc_table_long,
      path(results_dir, "ftolr/ftol_acc_table_long.csv")
    )
  ),
  tar_file(
    acc_table_wide_ftolr,
    write_csv_tar(
      acc_table_wide,
      path(results_dir, "ftolr/ftol_acc_table_wide.csv")
    )
  ),
  # - Taxonomy
  tar_file(
    sanger_sampling_ftolr,
    write_csv_tar(
      sanger_sampling,
      path(results_dir, "ftolr/ftol_sanger_sampling.csv")
    )
  ),
  # - Trees (all trees should be rooted)
  # -- plastome consensus
  tar_file(
    plastome_tree_ftolr,
    write_tree_tar(
      plastome_tree_rooted,
      path(results_dir, "ftolr/ftol_plastome_con.tre")
    )
  ),
  # -- sanger ML
  tar_file(
    sanger_ml_tree_ftolr,
    write_tree_tar(
      sanger_mlr_tree_rooted,
      path(results_dir, "ftolr/ftol_sanger_ml.tre")
    )
  ),
  # -- sanger ML dated
  tar_file(
    sanger_ml_tree_dated_ftolr,
    write_tree_tar(
      sanger_mlr_tree_dated,
      path(results_dir, "ftolr/ftol_sanger_ml_dated.tre")
      )
  ),
  # -- sanger consensus
  tar_file(
    sanger_con_tree_ftolr,
    write_tree_tar(
      sanger_con_tree_rooted,
      path(results_dir, "ftolr/ftol_sanger_con.tre")
    )
  ),
  # -- sanger consensus dated
  tar_file(
    sanger_con_tree_dated_ftolr,
    write_tree_tar(
      sanger_con_tree_dated,
      path(results_dir, "ftolr/ftol_sanger_con_dated.tre")
    )
  ),
  # - Alignments
  tar_file(
    sanger_alignment_ftolr,
    write_fasta_gz_tar(
      sanger_alignment,
      path(results_dir, "ftolr/ftol_sanger_alignment.fasta.gz")
    )
  ),
  tar_file(
    plastome_alignment_ftolr,
    write_fasta_gz_tar(
      plastome_alignment,
      path(results_dir, "ftolr/ftol_plastome_alignment.fasta.gz")
    )
  ),
  # - Alignment parts
  tar_file(
    plastome_parts_table_ftolr,
    write_csv_tar(
      plastome_parts_table,
      path(results_dir, "ftolr/ftol_plastome_parts.csv")
    )
  ),
  tar_file(
    sanger_parts_table_ftolr,
    write_csv_tar(
      sanger_parts_table,
      path(results_dir, "ftolr/ftol_sanger_parts.csv")
    )
  ),
  # - Calibration points
  tar_file(
    con_fossil_calibration_tips_ftolr,
    write_csv_tar(
      con_fossil_calibration_tips,
      path(results_dir, "ftolr/ftol_sanger_con_fossils.csv")
    )
  ),
  tar_file(
    ml_fossil_calibration_tips_ftolr,
    write_csv_tar(
      ml_fossil_calibration_tips,
      path(results_dir, "ftolr/ftol_sanger_ml_fossils.csv")
    )
  ),
  # Compress data for FigShare
  tar_file(
    ref_aln_archive,
    archive_dir(
      archive = path(data_raw, "ref_aln.tar.gz"),
      dir = path(data_raw, "ref_aln"),
      format = "tar",
      filter = "gzip",
      depends = ref_aln_files
    )
  ),
  # Render READMEs
  data_readme_tar,
  ftolr_readme_tar,
  # Archive data for ftolr
  tar_file(
    ftolr_data_archive,
    { # Write a temporary CC0 license to include in data archive. # no lint
      cc0 <- write_cc0()
      zip::zip(
        zipfile = path(results_dir, "ftol.zip"),
        files = c(
          # accessions
          acc_table_long_ftolr, acc_table_wide_ftolr,
          # taxonomy
          sanger_sampling_ftolr,
          # trees
          plastome_tree_ftolr,
          sanger_ml_tree_ftolr, sanger_ml_tree_dated_ftolr,
          sanger_con_tree_ftolr, sanger_con_tree_dated_ftolr,
          # alignments
          sanger_alignment_ftolr, plastome_alignment_ftolr,
          plastome_parts_table_ftolr, sanger_parts_table_ftolr,
          # fossils
          con_fossil_calibration_tips_ftolr, ml_fossil_calibration_tips_ftolr,
          # README
          ftolr_readme[[1]],
          # CC0 license
          cc0
        ),
        mode = "cherry-pick"
      )
      fs::file_delete(cc0)
      path(results_dir, "ftol.zip")
    }
  )
)
